# 链表
常见的链表结构：单链表、双向链表、循环链表

链表的内存块称为链表的结点，每个链表的结点除了存储数据之外，还记录链上的下一个结点的地址。我们把记录下一个结点的指针叫做后继指针next

## 单链表

单链表习惯性把第一个结点叫做头结点，把最后一个结点叫做尾结点，头结点用来记录链表的基本地址，尾结点指针不是指向下一个结点，而是指向一个空地址Null，表示这是链表上最后一个结点

## 循环链表

循环链表和单链表唯一的区别就是循环链表的尾结点指针指向链表的头结点，当要处理的数据具有环形结构特点时，特别适合采用循环链表，例如：约瑟夫问题

## 双链表

双向链表每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点

# 问题解答

缓存淘汰策略：
先进先出 ： FIFO(First In,First Out)
最少使用策略：LFU(Least Frequently Used)
最近最少使用策略：LRU(Least Recently Used)

用链表实现LRU:

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2.如果此数据没有在缓存链表中，又可以分为两种情况：
如果此时缓存未满，则将此结点直接插入到链表的头部；
如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
这样我们就用链表实现了一个LRU缓存，是不是很简单

